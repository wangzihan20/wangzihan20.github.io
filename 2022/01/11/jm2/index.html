<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="王梓涵"><title>数学建模|图与网络模型 · 王梓涵的Blog</title><meta name="description" content="图论的基本介绍
由于博主专业，在此不再赘述图论的基本知识算法。 想了解基础知识，请参考图论（一）基本概念与邻接矩阵
顺带一提： - 对于有向图，只要写出邻接矩阵，直接使用Matlab命令：sparse，可以将邻接矩阵转化为稀疏矩阵的表示方式。 - 对于无向图，由于邻接矩阵是对称的，Matlab中"><meta name="keywords" content="Blog,博客,Hexo"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.webp"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/insight.css"><link rel="stylesheet" href="/css/search.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><script src="/js/jquery.js"></script><meta name="generator" content="Hexo 5.4.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="page-top animated fadeInDown"><div class="nav"><li> <a href="/">博客主页</a></li><li> <a href="/archives">文章归档</a></li><li> <a href="/个人简历/">个人简历</a></li><li> <a href="/tags">标签</a></li><li> <a href="/about">关于</a></li><li> <a href="/links">友链</a></li><li> <a href="/test1">杂记</a></li></div><div class="information"><div class="nav_right_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li><li><a class="fa fa-search" onclick="openWindow();"></a></li></div><div class="avatar"><img src="/images/logo.webp"></div></div></div><div class="sidebar animated fadeInDown"><div class="sidebar-top"><div class="logo-title"><div class="title"><img src="/images/logo@2x.webp" style="width:200px;" alt="favicon"><h3 title=""><a href="/">王梓涵的Blog</a></h3><div class="description"><p>一个日常记录学习的blog……</p></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="https://github.com"><i class="fa fa-github"></i></a></li><li><a href="mailto:2018952617@qq.com"><i class="fa fa-envelope"></i></a></li><li><a target="_blank" rel="noopener" href="http://sighttp.qq.com/authd?IDKEY=https://user.qzone.qq.com/2018952617/infocenter"><i class="fa fa-qq"></i></a></li><li><a target="_blank" rel="noopener" href="https://zhihu.com"><i class="fa fa-mortar-board"></i></a></li></ul></div></div><div class="footer"><div class="p"> <span> 全站CC-BY-SA-3.0 </span><i class="fa fa-star"></i><span> 王梓涵</span></div><div class="by_farbox"><span>Powered by </span><a href="https://hexo.io/zh-cn/" target="_blank">Hexo </a><span> & </span><span>Anatolo </span></div><div class="beian"></div></div></div><div class="main"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>数学建模|图与网络模型</a></h3></div><div class="post-content"><p><h2 id="图论的基本介绍"><strong>图论的基本介绍</strong></h2>
<p>由于博主专业，在此不再赘述图论的基本知识算法。 想了解基础知识，请参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/saltriver/article/details/54428685?utm_source=app&amp;app_version=4.18.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">图论（一）基本概念</a>与<a target="_blank" rel="noopener" href="https://blog.csdn.net/diviner_s/article/details/106978910?utm_source=app&amp;app_version=4.18.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">邻接矩阵</a></p>
<p><strong>顺带一提</strong>： - 对于有向图，只要写出邻接矩阵，直接使用Matlab命令：sparse，可以将邻接矩阵转化为稀疏矩阵的表示方式。 - 对于无向图，由于邻接矩阵是对称的，Matlab中只需要使用邻接矩阵的下三角元素 - 稀疏矩阵可以使用full命令变成普通矩阵。</p>
<h2 id="最短路径问题">最短路径问题</h2>
<h3 id="两个顶点之间的最短问题">两个顶点之间的最短问题</h3>
<h4 id="dijkstra算法">Dijkstra算法</h4>
<p>基本步骤：</p>
<ol type="1">
<li>首先，定义一个数组 D，D[v] 表示从源点 s 到顶点 v 的边的权值，如果没有边则将 D[v] 置为无穷大。</li>
<li>把图的顶点集合划分为两个集合 S 和 V-S。第一个集合 S 表示距源点最短距离已经确定的顶点集，即一个顶点如果属于集合 S 则说明从源点 s 到该顶点的最短路径已知。其余的顶点放在另一个集合 V-S 中。</li>
<li>每次从尚未确定最短路径长度的集合 V-S 中取出一个最短特殊路径长度最小的顶点 u，将 u 加入集合 S，同时修改数组 D 中由 s 可达的最短路径长度。若加入集合 S 的 u 作为中间顶点时，vi 的最短路特殊路径长度变短，则修改 vi 的距离值（即当D[u] + W[u, vi] &lt; D[vi]时，令D[vi] = D[u] + W[u, vi]）。</li>
<li>重复第 3 步的操作，一旦 S 包含了所有 V 中的顶点，D 中各顶点的距离值就记录了从源点 s 到该顶点的最短路径长度。</li>
</ol>
<h5 id="matlab代码及例子">Matlab代码及例子</h5>
<img src="/2022/01/11/jm2/1.jpg" class>
<p>Matlab代码实现</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clc,clear all</span><br><span class="line">a=<span class="built_in">zeros</span>(<span class="number">6</span>);</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>)=<span class="number">50</span>;a(<span class="number">1</span>,<span class="number">4</span>)=<span class="number">40</span>;a(<span class="number">1</span>,<span class="number">5</span>)=<span class="number">25</span>;a(<span class="number">1</span>,<span class="number">6</span>)=<span class="number">10</span>;               </span><br><span class="line">a(<span class="number">2</span>,<span class="number">3</span>)=<span class="number">15</span>;a(<span class="number">2</span>,<span class="number">4</span>)=<span class="number">20</span>;a(<span class="number">2</span>,<span class="number">6</span>)=<span class="number">25</span>;</span><br><span class="line">a(<span class="number">3</span>,<span class="number">4</span>)=<span class="number">10</span>;a(<span class="number">3</span>,<span class="number">5</span>)=<span class="number">20</span>;</span><br><span class="line">a(<span class="number">4</span>,<span class="number">5</span>)=<span class="number">10</span>;a(<span class="number">4</span>,<span class="number">6</span>)=<span class="number">25</span>;</span><br><span class="line">a(<span class="number">5</span>,<span class="number">6</span>)=<span class="number">55</span>;</span><br><span class="line">a=a+a'                                                  </span><br><span class="line">a(<span class="built_in">find</span>(a==<span class="number">0</span>))=<span class="built_in">inf</span> <span class="comment">%将a=0的数全部替换为无强大               </span></span><br><span class="line">pb(<span class="number">1</span>:<span class="built_in">length</span>(a))=<span class="number">0</span>;pb(<span class="number">1</span>)=<span class="number">1</span>;  <span class="comment">%当一个点已经求出到原点的最短距离时，其下标i对应的pb(i)赋1</span></span><br><span class="line">index1=<span class="number">1</span>; <span class="comment">%存放存入S集合的顺序</span></span><br><span class="line">index2=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="built_in">length</span>(a)); <span class="comment">%存放始点到第i点最短通路中第i顶点前一顶点的序号</span></span><br><span class="line">d(<span class="number">1</span>:<span class="built_in">length</span>(a))=<span class="built_in">inf</span>;d(<span class="number">1</span>)=<span class="number">0</span>;  <span class="comment">%存放由始点到第i点最短通路的值</span></span><br><span class="line">temp=<span class="number">1</span>;  <span class="comment">%temp表示c1,算c1到其它点的最短路。</span></span><br><span class="line"><span class="keyword">while</span> sum(pb)&lt;<span class="built_in">length</span>(a)  <span class="comment">%看是否所有的点都标记为P标号</span></span><br><span class="line">tb=<span class="built_in">find</span>(pb==<span class="number">0</span>); <span class="comment">%找到标号为0的所有点,即找到还没有存入S的点</span></span><br><span class="line">d(tb)=<span class="built_in">min</span>(d(tb),d(temp)+a(temp,tb));<span class="comment">%计算标号为0的点的最短路，或者是从原点直接到这个点，又或者是原点经过r1,间接到达这个点</span></span><br><span class="line">tmpb=<span class="built_in">find</span>(d(tb)==<span class="built_in">min</span>(d(tb)));  <span class="comment">%求d[tb]序列最小值的下标</span></span><br><span class="line">temp=tb(tmpb(<span class="number">1</span>));<span class="comment">%可能有多条路径同时到达最小值，却其中一个，temp也从原点变为下一个点</span></span><br><span class="line">pb(temp)=<span class="number">1</span>;<span class="comment">%找到最小路径的表对应的pb(i)=1</span></span><br><span class="line">index1=[index1,temp];  <span class="comment">%存放存入S集合的顺序</span></span><br><span class="line">temp2=<span class="built_in">find</span>(d(index1)==d(temp)-a(temp,index1));</span><br><span class="line">index2(temp)=index1(temp2(<span class="number">1</span>)); <span class="comment">%记录标号索引</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d, index1, index2</span><br></pre></td></tr></table></figure>
<h5 id="java代码实现">Java代码实现</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">10000</span>;     <span class="comment">// 约定 10000 代表距离无穷大</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] vertexes = { <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span> };    <span class="comment">// 顶点</span></span><br><span class="line">        <span class="keyword">int</span>[][] weight = {  	<span class="comment">// 图的邻接矩阵</span></span><br><span class="line">                    <span class="comment">/*A*/</span><span class="comment">/*B*/</span><span class="comment">/*C*/</span><span class="comment">/*D*/</span><span class="comment">/*E*/</span><span class="comment">/*F*/</span><span class="comment">/*G*/</span></span><br><span class="line">                <span class="comment">/*A*/</span>{<span class="number">0</span>,   <span class="number">5</span>,   <span class="number">7</span>,   N,   N,   N,   <span class="number">2</span>},</span><br><span class="line">                <span class="comment">/*B*/</span>{<span class="number">5</span>,   <span class="number">0</span>,   N,   <span class="number">9</span>,   N,   N,   <span class="number">3</span>},</span><br><span class="line">                <span class="comment">/*C*/</span>{<span class="number">7</span>,   N,   <span class="number">0</span>,   N,   <span class="number">8</span>,   N,   N},</span><br><span class="line">                <span class="comment">/*D*/</span>{N,   <span class="number">9</span>,   N,   <span class="number">0</span>,   N,   <span class="number">4</span>,   N},</span><br><span class="line">                <span class="comment">/*E*/</span>{N,   N,   <span class="number">8</span>,   N,   <span class="number">0</span>,   <span class="number">5</span>,   <span class="number">4</span>},</span><br><span class="line">                <span class="comment">/*F*/</span>{N,   N,   N,   <span class="number">4</span>,   <span class="number">5</span>,   <span class="number">0</span>,   <span class="number">6</span>},</span><br><span class="line">                <span class="comment">/*G*/</span>{<span class="number">2</span>,   <span class="number">3</span>,   N,   N,   <span class="number">4</span>,   <span class="number">6</span>,   <span class="number">0</span>}</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> source = <span class="number">6</span>; <span class="comment">// 源点下标</span></span><br><span class="line">        <span class="keyword">int</span>[] dis = dijkstra(source, vertexes, weight);	<span class="comment">// 使用迪杰斯特拉查找最短路径</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出最短路径长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;dis.length; i++){</span><br><span class="line">            System.out.println(vertexes[source] + <span class="string">"-&gt;"</span> + vertexes[i] + <span class="string">" = "</span> + dis[i]);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迪杰斯特拉算法求解最短路径问题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> source    源点下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertexes  顶点集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight    邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int[]    源点到各顶点最短路径距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] dijkstra(<span class="keyword">int</span> source, <span class="keyword">char</span>[] vertexes, <span class="keyword">int</span>[][] weight){</span><br><span class="line">        <span class="keyword">int</span>[] dis;     <span class="comment">// 记录源点到各顶点的最短路径长度,如 dis[2] 表示源点到下标为 2 的顶点的最短路径长度</span></span><br><span class="line">        ArrayList&lt;Character&gt; S = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 存储已经求出到源点最短路径的顶点，即算法步骤中的 S 集合。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化源点 */</span></span><br><span class="line">        dis = weight[source];</span><br><span class="line">        S.add(vertexes[source]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 当 S 集合元素个数等于顶点个数时，说明最短路径查找完毕 */</span></span><br><span class="line">        <span class="keyword">while</span>(S.size() != vertexes.length){</span><br><span class="line">            <span class="keyword">int</span> min = N;</span><br><span class="line">            <span class="keyword">int</span> index = -<span class="number">1</span>; <span class="comment">// 记录已经求出最短路径的顶点下标</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 从 V-S 的集合中找距离源点最近的顶点 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;weight.length; j++){</span><br><span class="line">                <span class="keyword">if</span> (!S.contains(vertexes[j]) &amp;&amp; dis[j] &lt; min){</span><br><span class="line">                    min = weight[source][j];</span><br><span class="line">                    index = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            dis[index] = min;   <span class="comment">// 更新源点到该顶点的最短路径长度</span></span><br><span class="line">            S.add(vertexes[index]); <span class="comment">// 将顶点加入到 S 集合中，即表明该顶点已经求出到源点的最小路径</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 更新源点经过下标为 index 的顶点到其它各顶点的最短路径 */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;weight.length; m++){</span><br><span class="line">                <span class="keyword">if</span> (!S.contains(vertexes[m]) &amp;&amp; dis[index] + weight[index][m] &lt; dis[m]){</span><br><span class="line">                    dis[m] = dis[index] + weight[index][m];</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dis;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="section"></h5>
<h3 id="每个顶点之间的最短路径">每个顶点之间的最短路径</h3>
<h4 id="迭代使用n-1次dijkstra算法">迭代使用n-1次Dijkstra算法</h4>
<h4 id="floyd算法">Floyd算法</h4>
<p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）。 <strong>从任意节点i到任意节点j的最短路径不外乎两种可能：</strong></p>
<ul>
<li>一是直接从i到j，</li>
<li>二是从i经过若干个节点k到j。</li>
</ul>
<p>所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立。 如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<img src="/2022/01/11/jm2/2.png" class>
<h5 id="c语言实现">c语言实现</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>{</span></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="keyword">int</span>** G;					<span class="comment">// 邻接矩阵</span></span><br><span class="line">		<span class="keyword">int</span>** dist;					<span class="comment">// 距离数组 </span></span><br><span class="line">		<span class="keyword">int</span>** path;					<span class="comment">// 路径数组 </span></span><br><span class="line">		<span class="keyword">int</span> Nv;						<span class="comment">// 顶点数</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//构造函数</span></span><br><span class="line">		Graph(<span class="keyword">int</span> nv, <span class="keyword">int</span> ne){</span><br><span class="line">			<span class="keyword">this</span>-&gt;Nv = nv;</span><br><span class="line">			G = <span class="keyword">new</span> <span class="keyword">int</span>*[nv+<span class="number">1</span>];</span><br><span class="line">			dist = <span class="keyword">new</span> <span class="keyword">int</span>*[nv+<span class="number">1</span>];</span><br><span class="line">			path = <span class="keyword">new</span> <span class="keyword">int</span>*[nv+<span class="number">1</span>]; </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nv+<span class="number">1</span> ; i++){</span><br><span class="line">				G[i] = <span class="keyword">new</span> <span class="keyword">int</span>[nv+<span class="number">1</span>];</span><br><span class="line">				dist[i] = <span class="keyword">new</span> <span class="keyword">int</span>[nv+<span class="number">1</span>];</span><br><span class="line">				path[i] = <span class="keyword">new</span> <span class="keyword">int</span>[nv+<span class="number">1</span>];</span><br><span class="line">				<span class="built_in">memset</span>(path[i],<span class="number">-1</span>,<span class="keyword">sizeof</span>(path[<span class="number">0</span>][<span class="number">0</span>])*(nv+<span class="number">1</span>));</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; nv+<span class="number">1</span> ; j++){</span><br><span class="line">					<span class="keyword">this</span>-&gt;G[i][j] = <span class="keyword">this</span>-&gt;dist[i][j] = MAX;</span><br><span class="line">				} </span><br><span class="line">				<span class="keyword">this</span>-&gt;G[i][i] = <span class="keyword">this</span>-&gt;dist[i][i] = <span class="number">0</span>; </span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入边与权重:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			<span class="keyword">for</span>( i = <span class="number">0</span> ; i &lt; ne ; i++){</span><br><span class="line">				<span class="keyword">int</span> v1,v2,weight;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;weight;</span><br><span class="line">				<span class="keyword">this</span>-&gt;G[v1][v2] = <span class="keyword">this</span>-&gt;G[v2][v1] = weight;</span><br><span class="line">				<span class="keyword">this</span>-&gt;dist[v1][v2] = <span class="keyword">this</span>-&gt;dist[v2][v1] = weight;</span><br><span class="line">			}	</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//Floyd算法(多源最短路径算法) </span></span><br><span class="line">		<span class="function"><span class="keyword">bool</span> <span class="title">Floyd</span><span class="params">()</span></span>{</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; k++){	<span class="comment">//k代表中间顶点 </span></span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>  ; i &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; i++){<span class="comment">//i代表起始顶点 </span></span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; j++){<span class="comment">//j代表终点 </span></span><br><span class="line">						<span class="keyword">if</span>(<span class="keyword">this</span>-&gt;dist[i][k] + <span class="keyword">this</span>-&gt;dist[k][j] &lt; <span class="keyword">this</span>-&gt;dist[i][j]){</span><br><span class="line">							<span class="keyword">this</span>-&gt;dist[i][j] = <span class="keyword">this</span>-&gt;dist[i][k] + <span class="keyword">this</span>-&gt;dist[k][j];</span><br><span class="line">							<span class="keyword">if</span>(i == j &amp;&amp; <span class="keyword">this</span>-&gt;dist[i][j] &lt; <span class="number">0</span>){<span class="comment">//发现了负值圈 </span></span><br><span class="line">								<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">							}</span><br><span class="line">							<span class="keyword">this</span>-&gt;path[i][j] = k;</span><br><span class="line">						}					</span><br><span class="line">					}</span><br><span class="line">				}</span><br><span class="line">			}</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 分治法寻找start到end最短路径的中间结点 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; &amp;q ,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>{</span><br><span class="line">			<span class="keyword">int</span> mid = <span class="keyword">this</span>-&gt;path[start][end];</span><br><span class="line">			<span class="keyword">if</span>(mid == <span class="number">-1</span>){</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			}</span><br><span class="line">			Find(q,start,mid);</span><br><span class="line">			q.push(mid);</span><br><span class="line">			Find(q,mid,end);</span><br><span class="line">		}</span><br><span class="line"></span><br><span class="line">		<span class="comment">//打印start顶点到end顶点的路径 </span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Print_Path</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>{</span><br><span class="line">			<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">queue</span>;</span><br><span class="line">			<span class="built_in">queue</span>.push(start);</span><br><span class="line">			<span class="keyword">this</span>-&gt;Find(<span class="built_in">queue</span>,start,end); </span><br><span class="line">			<span class="built_in">queue</span>.push(end);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">queue</span>.front();</span><br><span class="line">			<span class="built_in">queue</span>.pop();</span><br><span class="line">			<span class="keyword">while</span>(!<span class="built_in">queue</span>.empty()){</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;<span class="built_in">queue</span>.front();</span><br><span class="line">				<span class="built_in">queue</span>.pop();</span><br><span class="line">			}</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		}</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Print_Floyd</span><span class="params">()</span></span>{</span><br><span class="line">			<span class="keyword">int</span> i,j,k;</span><br><span class="line">			<span class="keyword">for</span>( i = <span class="number">1</span> ; i &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; i++){</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; j++){</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;path[i][j]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			} </span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"	length		path"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">1</span> ; i &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; i++){</span><br><span class="line">				<span class="keyword">for</span>(j = i+<span class="number">1</span> ; j &lt; <span class="keyword">this</span>-&gt;Nv+<span class="number">1</span> ; j++){</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">"-&gt;"</span>&lt;&lt;j&lt;&lt;<span class="string">"	"</span>;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;dist[i][j]&lt;&lt;<span class="string">"		"</span>; 	</span><br><span class="line">					<span class="keyword">this</span>-&gt;Print_Path(i,j);</span><br><span class="line">				}</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入顶点数与边长数:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> nv,ne;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;nv&gt;&gt;ne; </span><br><span class="line">	<span class="function">Graph <span class="title">graph</span><span class="params">(nv,ne)</span></span>;</span><br><span class="line">	<span class="keyword">if</span>(graph.Floyd()){</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"各个顶点的最短路径为："</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">		graph.Print_Floyd();</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> }</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果：</strong></p>
<img src="/2022/01/11/jm2/3.png" class>
<h2 id="最小生成树">最小生成树</h2>
<p><strong>连通的无圈图叫作树，度为1的叫作叶子结点。</strong></p>
<p><strong>应用问题例子</strong>：欲修筑连接<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container></span>个城市的铁路，已知<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container></span>城与<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container></span>城之间的铁路造价为<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.666ex" xmlns="http://www.w3.org/2000/svg" width="2.378ex" height="1.666ex" role="img" focusable="false" viewbox="0 -442 1051.3 736.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"/></g><g data-mml-node="TeXAtom" transform="translate(466,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(345,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></g></g></svg></mjx-container></span>,设计一个路线图，使得总造价最低。</p>
<h3 id="prim算法以点为主每次选择下一个中最小权重">Prim算法（以点为主，每次选择下一个中最小权重）</h3>
<h4 id="基本思想">基本思想</h4>
<img src="/2022/01/11/jm2/4.jpg" class>
<p><strong>例子</strong>：</p>
<img src="/2022/01/11/jm2/5.jpg" class>
<p><strong>Matlab实现：</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line">a=<span class="built_in">zeros</span>(<span class="number">7</span>);</span><br><span class="line">a(<span class="number">1</span>,<span class="number">2</span>)=<span class="number">50</span>;a(<span class="number">1</span>,<span class="number">3</span>)=<span class="number">60</span>;</span><br><span class="line">a(<span class="number">2</span>,<span class="number">4</span>)=<span class="number">65</span>;a(<span class="number">2</span>,<span class="number">5</span>)=<span class="number">40</span>;</span><br><span class="line">a(<span class="number">3</span>,<span class="number">4</span>)=<span class="number">52</span>;a(<span class="number">3</span>,<span class="number">7</span>)=<span class="number">45</span>;</span><br><span class="line">a(<span class="number">4</span>,<span class="number">5</span>)=<span class="number">50</span>;a(<span class="number">4</span>,<span class="number">6</span>)=<span class="number">30</span>;a(<span class="number">4</span>,<span class="number">7</span>)=<span class="number">42</span>;</span><br><span class="line">a(<span class="number">5</span>,<span class="number">6</span>)=<span class="number">70</span>;</span><br><span class="line">a=a+a';a(<span class="built_in">find</span>(a==<span class="number">0</span>))=<span class="built_in">inf</span>;</span><br><span class="line">result=[];</span><br><span class="line">p=<span class="number">1</span>;      <span class="comment">%起点为1</span></span><br><span class="line">tb=<span class="number">2</span>:<span class="built_in">length</span>(a);</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">length</span>(result)~=<span class="built_in">length</span>(a)<span class="number">-1</span></span><br><span class="line">    temp=a(p,tb);temp=temp(:);</span><br><span class="line">    d=<span class="built_in">min</span>(temp);</span><br><span class="line">    [jb,kb]=<span class="built_in">find</span>(a(p,tb)==d);</span><br><span class="line">    <span class="built_in">j</span>=p(jb(<span class="number">1</span>));k=tb(kb(<span class="number">1</span>));</span><br><span class="line">    result=[result,[<span class="built_in">j</span>;k;d]];p=[p,k];tb(<span class="built_in">find</span>(tb==k))=[];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">result</span><br></pre></td></tr></table></figure>
<h3 id="kruskal算法以边为主每次选最小">Kruskal算法(以边为主，每次选最小)</h3>
<h4 id="基本思想-1">基本思想</h4>
<p>将图的n个顶点看作n个分离的部分树，每个树具有一个顶点，算法的每一步就是选择连接两个分离树的具有最小权值的边，将两个树合二为一，直到只有一个树为止（进行n-1步）得到最小生成树。</p>
<p><strong>例子</strong>：</p>
<p>我们使用边权矩阵进行存储数据，边权矩阵就是<strong>按列写入，每列由出发顶点、接收顶点和边的权值组成</strong>，如下所示：</p>
<img src="/2022/01/11/jm2/6.jpg" class>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%边权矩阵，每一列都表示一条边，从上到下分别为两个顶点以及它们边的权值</span></span><br><span class="line">b = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">     <span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span>;</span><br><span class="line">     <span class="number">8</span> <span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span> <span class="number">10</span> <span class="number">3</span>];</span><br><span class="line"><span class="comment">%sortrows函数对某一列进行比较排序，所以我们先转置b矩阵，然后对第三列也就是权值进行排序</span></span><br><span class="line">[B,<span class="built_in">i</span>]=<span class="built_in">sortrows</span>(b',<span class="number">3</span>);</span><br><span class="line"><span class="comment">%再将其转置回来</span></span><br><span class="line">B=B';</span><br><span class="line"><span class="comment">%m为边的条数，n为点的个数</span></span><br><span class="line">m=<span class="built_in">size</span>(b,<span class="number">2</span>);n=<span class="number">5</span>;</span><br><span class="line"><span class="comment">%t数组用来标记选中的边，k用来计数，T矩阵用来存储选中的边，c计算最小生成树的总长度</span></span><br><span class="line">t=<span class="number">1</span>:n;k=<span class="number">0</span>;T=[];c=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line">    <span class="keyword">if</span> t(B(<span class="number">1</span>,<span class="built_in">i</span>))~=t(B(<span class="number">2</span>,<span class="built_in">i</span>))</span><br><span class="line">        k=k+<span class="number">1</span>;T(k,<span class="number">1</span>:<span class="number">2</span>)=B(<span class="number">1</span>:<span class="number">2</span>,<span class="built_in">i</span>),c=c+B(<span class="number">3</span>,<span class="built_in">i</span>);</span><br><span class="line">        tmin=<span class="built_in">min</span>(t(B(<span class="number">1</span>,<span class="built_in">i</span>)),t(B(<span class="number">2</span>,<span class="built_in">i</span>)));</span><br><span class="line">        tmax=<span class="built_in">max</span>(t(B(<span class="number">1</span>,<span class="built_in">i</span>)),t(B(<span class="number">2</span>,<span class="built_in">i</span>)));</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n</span><br><span class="line">            <span class="keyword">if</span> t(<span class="built_in">j</span>)==tmax</span><br><span class="line">                t(<span class="built_in">j</span>)=tmin;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> k==n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">T,c,</span><br></pre></td></tr></table></figure>
<h2 id="网络最大流">网络最大流</h2>
<h3 id="何为最大流问题">何为最大流问题？</h3>
<p>参考博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43838785/article/details/102879239?utm_source=app&amp;app_version=4.18.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">网络流——最大流（全）</a></p>
<h3 id="matlab实现">Matlab实现</h3>
<p>最大流问题(maximum flow problem)，一种组合最优化问题，就是要讨论如何充分利用装置的能力，使得运输的流量最大，以取得最好的效果。管道网络中每条边的最大通过能力（容量）是有限的，实际流量不超过容量。</p>
<p>在数学建模的过程中时长会遇到这种问题，存在专门的算法去解决这一问题，但其实现较为复杂。</p>
<p><strong>MATLAB提供了解决这一问题所使用的函数，即maxflow函数。</strong></p>
<p><strong>语法</strong>:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mf = maxflow(G,s,t)</span><br><span class="line">mf = maxflow(G,s,t,algorithm)</span><br><span class="line">[mf,GF] = maxflow(___)</span><br><span class="line">[mf,GF,cs,ct] = maxflow(___)</span><br></pre></td></tr></table></figure>
<p><strong>符号说明</strong>：</p>
<ul>
<li>mf = maxflow(G,s,t) 返回节点 s 和 t 之间的最大流。如果图 G 未加权（即 G.Edges 不包含变量 Weight），则 maxflow 将所有图边的权重视为 1。</li>
<li>mf = maxflow(G,s,t,algorithm) 指定要使用的最大流算法。此语法仅在 G 为有向图时可用。</li>
<li>[mf,GF] = maxflow(___) 还使用上述语法中的任何输入参数返回有向图对象 GF。GF 仅使用 G 中具有非零流值的边构造。</li>
<li>[mf,GF,cs,ct] = maxflow(___) 还返回源和目标节点 ID cs 和 ct，表示与最大流相关联的最小割。</li>
</ul>
<p><strong>创建并绘制一个加权图。加权边表示流量。</strong></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span>];</span><br><span class="line">t = [<span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">4</span> <span class="number">6</span>];</span><br><span class="line">weights = [<span class="number">0.77</span> <span class="number">0.44</span> <span class="number">0.67</span> <span class="number">0.75</span> <span class="number">0.89</span> <span class="number">0.90</span> <span class="number">2</span> <span class="number">0.76</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">G = digraph(s,t,weights);</span><br><span class="line"><span class="built_in">plot</span>(G,<span class="string">'EdgeLabel'</span>,G.Edges.Weight,<span class="string">'Layout'</span>,<span class="string">'layered'</span>);</span><br></pre></td></tr></table></figure>
<img src="/2022/01/11/jm2/7.jpg" class>
<p><strong>确定节点1到6的最大流</strong>:</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mf = maxflow(G,<span class="number">1</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p><strong>结果</strong>：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mf =</span><br><span class="line"></span><br><span class="line">    <span class="number">1.2100</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/wmhsjtu/article/details/104149007?utm_source=app&amp;app_version=4.18.0&amp;code=app_1562916241&amp;uLinkId=usr1mkqgl919blen">图的最大流问题（含matlab函数使用方法）</a></p>
</blockquote>
<h2 id="matlab图论工具箱">Matlab图论工具箱</h2>
<img src="/2022/01/11/jm2/8.jpg" class>
</p><div class="tip">本文采用CC-BY-SA-3.0协议，转载请注明出处<br>作者: 王梓涵</div></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-01-11</span><i class="fa fa-tag"></i><a class="tag" href="/tags/数学建模/" title="数学建模">数学建模 </a><span class="leancloud_visitors"></span><span>大约3193个字, 10分钟38秒读完</span></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="" onclick="javascript:join_favorite()" ref="sidebar"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://wangzihan20.github.io/2022/01/11/jm2/,王梓涵的Blog,数学建模|图与网络模型,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/01/12/mathrecord7/" title="笔记|统计学习方法：逻辑斯蒂回归与最大熵">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/01/10/jm1/" title="数学建模|规划问题">下一篇</a></li></ul></div><script src="/js/visitors.js"></script><a id="comments"></a><div id="vcomments" style="margin:0 30px;"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/gh/xcss/valine@latest/dist/Valine.min.js"></script><script>var valine = new Valine({
  el:'#vcomments',
  notify:false || false, 
  verify:false|| false, 
  app_id:'MHBF2e7yy2pSKFS6UAwUMxcW-gzGzoHsz',
  app_key:'n7EU7557kB8wtS17f6czpfGe',
  placeholder:'请开始你的表演，请文明发言哦！',
  path: window.location.pathname,
  serverURLs: '',
  visitor:true,
  recordIP:true,
  avatar:'retro'
})</script></div></div></div></div><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/add-bookmark.js"></script><script>(function(window){var INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)",},CONTENT_URL:"/content.json",};window.INSIGHT_CONFIG=INSIGHT_CONFIG})(window);</script><script src="/js/insight.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="想要查找什么..."><span class="searchbox-close"><a class="fa fa-times-circle" onclick="closeWindow();"></a></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"><p>Seraching...</p></div></div></div></div></body></html>